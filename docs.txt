return code
100 friend related
    110 + return code

    101 add friend success
    102 add friend failed
    103 already friend
    104 friend req has send, wait to accept
200 message related
    210 + return code

    201 send message success
    202 target is not friend
    203 send message failed
    204 target is offline
300 target status
    target come online
    target offline
    
    
400 toxcore related
    401 toxcore offline
    402 connect OK
    
分包过程
    这个信息传输应该是序列化的，所以只要在每个包上加一个id就行了，就用uuid
    
    
整体通信过程设计
    显然这个需要双向的即时通信。
    toxcore 和 node.js 通信还是采用1问1答的方式。但是tcp是客户端和服务器的模型，怎么整呢。
    还是用tcp通信，但是通信一直都不关。这样设计起来太费事了
    还是采用之前设想的轮询的方式？但是这样数据量大的时候效率太低了
    或者再另开一个tcp连接，要么用udp重新设计一种模式
    再开一个连接显得太臃肿了
    
    网络结构
    
    A机 PORT a                                               B机 PORT b
        |                                                       |
     node.js binding                                        node.js binding
        |                                                       |
        |------->A机 toxcore -->------>------>--->  B机 toxcore--|
        
    node.js 在这个过程中完全不是必须的，引入的原因就是增加开发效率，但是现在通信过程过于复杂，反倒减少效率了。
    但是分包，和其他比较复杂的处理C感觉会很难做
    应该先把底层构建好了，再在上面构建应用层
    这就是一个双向通信的问题
    node 和本地还是应该长连，效率上会更高，底层的基本连接toxcore完全对node进行屏蔽，比如说加好友，判断在线，连接的建立
    过程。toxcore对上层暴露的就是一个每次传输最大1024 byte的通道
    
    整个过程
    1.node 启动，启动完成后启动本地toxcore 这时向 toxcore 传入 tox节点信息，远程ID和远程端口，如果没有远程ID和端口则进入监听模式
    2.node 建立本地tcp监听端口A
    3.toxcore 启动完成之后连接A端口，向node发送信息说明已经准备OK
    4.node 监听本地端口B， 等待本地程序连接B
    
    请求连接端就是如此，下面是接收连接端的过程
    1.node 启动只传入tox节点的信息
    2.node 建立本地tcp监听端口C
    3.toxcore 开始监听信息，同时和node的C端口建立连接
    4.toxcore 和对方建立连接，收到信息后将信息转发给node
    
    底层toxcore的建立连接过程
    请求连接端
    1.toxcore启动连接入tox网络
        载入以前的配置只保留ID信息，friend全部删除
    2.发送add friend 请求
    3.等待对方connect status变化
    4.发送握手信息确认连接
    5.连接成功
    
    接收连接端
    1.toxcore启动进入tox网络
    2.等待对方请求
    3.收到请求后将对方加入friend
    4.等待对方握手信息  #这是主动向对方发握手包速度会不会更快些
    
    具体的设计
    toxcore 方面
    toxcore开两个线程，一个用来监听本地端口，一个用来监听tox的消息
    主要的处理过程放在tox的线程里面。任务全部都做成队列。这是一个不错的设计
    toxcore主要做两件事情， 一个是接收node的信息，直接传给对方
    来自node的消息在另一个tcp的进程里面完成，远端信息的添加在回调函数里面完成，这样的话回调函数应该也另开一个线性，因为消息处理可能会阻塞
    另一个是接收对方的信息直接传给node
    这里需要两个队列，一个来自node的消息队列，另一个是来自对方的消息队列
    这里不采用一问一答的形式，toxcore不会直接对本地的node信息进行回复，确认连接应该在更底层和更高层进行
    
    主要的處理過程
    對於請求端，node向本地toxcore發送和接收信息就不用包含對方的ID信息
    對於接受請求端，就要包含ID信息，toxcore端根據請求的ID向對方發送指定信息
    
        
        
        341CCFBC
        C4D41C5B
        3AB89E31
        E7561C5D
        37E201D5
        DDBFA7AF
        C6B4EDD2
        D6A82F4B
        7D06A2ED
        3DE4
        341CCFBC
        C4D41C5B
        3AB89E31
        E7561C5D
        37E21D5D
        DBFA7AFC
        6B4EDD2D
        6A82F4B4
        01
        341CCFBCC4D41C5B3AB89E31E7561C5D37E201D5DDBFA7AFC6B4EDD2D6A82F4B7D06A2ED3DE4
        FC2BD4C82FC377648EB0CB29A6A7BA3356697F9848DFA2CD93B4219311C40722
        9D9D799FAD4EEF3EB2B56568DC61B3B49DF223C83FF1566739C7B936B792F344247F52397BB7
        9D9D799FAD4EEF3EB2B56568DC61B3B49DF223C83FF1566739C7B936B792F344
bugs
    第一次握手連接時總是不成功(fixed)
        原因是我把接受连接设计成阻塞的模式却忘记开新的线程了，导致收到连接请求后就一直堵在那里
    連接成功後信息總是會重複(fixed)
        这是幻觉，只发送了一遍，但是在显示的时候重复显示了
    handshake明明收到了,卻會被判定成沒收到(fixed)
        字符串处理的问题，最后一位没有加终止符，确切的说是加了，但是被后来的字符串给覆盖了
    传递的端口号值不对(fixed)
        端口号设置成uint8了
        
        
可能的问题
    内存泄露
    
    
    
    
由于是连续的传递信息，为了区分传进来的不同次数应该进行手动分割，
有没有必要进行分割
好像完全没有必要进行分包
直接传就行
试试直接传吧

本地连接还是应该开两个，一个专门用来传数据另一个用来传控制指令