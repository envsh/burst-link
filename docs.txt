return code
100 friend related
    101 add friend success
    102 add friend failed
    103 already friend
    104 friend req has send, wait to accept
200 message related
    201 send message success
    202 target is not friend
    203 send message failed
    204 target is offline
300 target status
    target come online
    target offline
    
分包过程
    这个信息传输应该是序列化的，所以只要在每个包上加一个id就行了，就用uuid
    
    
整体通信过程设计
    显然这个需要双向的即时通信。
    toxcore 和 node.js 通信还是采用1问1答的方式。但是tcp是客户端和服务器的模型，怎么整呢。
    还是用tcp通信，但是通信一直都不关。这样设计起来太费事了
    还是采用之前设想的轮询的方式？但是这样数据量大的时候效率太低了
    或者再另开一个tcp连接，要么用udp重新设计一种模式
    再开一个连接显得太臃肿了
    
    网络结构
    
    A机 PORT a                                               B机 PORT b
        |                                                       |
     node.js binding                                        node.js binding
        |                                                       |
        |------->A机 toxcore -->------>------>--->  B机 toxcore--|
        
    node.js 在这个过程中完全不是必须的，引入的原因就是增加开发效率，但是现在通信过程过于复杂，反倒减少效率了。
    但是分包，和其他比较复杂的处理C感觉会很难做
    应该先把底层构建好了，再在上面构建应用层
    这就是一个双向通信的问题
    node 和本地还是应该长连，效率上会更高，底层的基本连接toxcore完全对node进行屏蔽，比如说加好友，判断在线，连接的建立
    过程。toxcore对上层暴露的就是一个每次传输最大1024 byte的通道
    
    整个过程
    1.node 启动，启动完成后启动本地toxcore 这时向 toxcore 传入 tox节点信息，远程ID和远程端口，如果没有远程ID和端口则进入监听模式
    2.node 建立本地tcp监听端口A
    3.toxcore 启动完成之后连接A端口，向node发送信息说明已经准备OK
    4.node 监听本地端口B， 等待本地程序连接B
    
    请求连接端就是如此，下面是接收连接端的过程
    1.node 启动只传入tox节点的信息
    2.node 建立本地tcp监听端口C
    3.toxcore 开始监听信息，同时和node的C端口建立连接
    4.toxcore 和对方建立连接，收到信息后将信息转发给node
    
    底层toxcore的建立连接过程
    请求连接端
    1.toxcore启动连接入tox网络
        载入以前的配置只保留ID信息，friend全部删除
    2.发送add friend 请求
    3.等待对方connect status变化
    4.发送握手信息确认连接
    5.连接成功
    
    接收连接端
    1.toxcore启动进入tox网络
    2.等待对方请求
    3.收到请求后将对方加入friend
    4.等待对方握手信息  #这是主动向对方发握手包速度会不会更快些
    
    具体的设计
    toxcore 方面
    toxcore开两个线程，一个用来监听本地端口，一个用来监听tox的消息
    主要的处理过程放在tox的线程里面。任务全部都做成队列。这是一个不错的设计
    toxcore主要做两件事情， 一个是接收node的信息，直接传给对方
    来自node的消息在另一个tcp的进程里面完成，远端信息的添加在回调函数里面完成，这样的话回调函数应该也另开一个线性，因为消息处理可能会阻塞
    另一个是接收对方的信息直接传给node
    这里需要两个队列，一个来自node的消息队列，另一个是来自对方的消息队列
    这里不采用一问一答的形式，toxcore不会直接对本地的node信息进行回复，确认连接应该在更底层和更高层进行
    
    
    
        
        
        